package agent;

import java.util.ArrayList;
import java.util.List;

import control.SeededRandom;
import landscape.FitnessFunction;
import landscape.NKLandscape;

/**
 * The Agent class represents the agents that navigate the landscape. They use
 * their developmental program and blocks to construct their developmental strategy,
 * then execute their developmental strategy by incrementally making changes to their
 * phenotype.
 * 
 * This implementation uses the NKPhenotype for use on NK landscapes.
 * 
 * @author Jacob Ashworth
 *
 */
public class Agent {
	
	//Fields related to developmental strategy
	private List<Integer> program;
	private List<List<Step>> blocks;
	
	//These fields are generated by compileStrategy()
	private List<Step> strategy;
	/* This integer tracks the next step to run, so currentStep=0 means
	 * step 0 has not yet been executed. */
	private int currentStep = 0;
	 
	//Fields related to phenotype.
	public Phenotype phenotype;
	/* phenotypeHistory is indexed by step number, so phenotypeHistory.get(4)
	 * would give you the phenotype immediately before step 4 was executed */
	private List<Phenotype> phenotypeHistory;
	
	//Fields related to fitness
	private FitnessFunction fitnessFunction;
	private double fitness;
	//fitnessHistory is indexed the same as phenotypeHistory
	private List<Double> fitnessHistory;
	
	/**
	 * Default constructor for Agent. Creates an agent with a random initial phenotype,
	 * program, and blocks.
	 * 
	 * @param fitnessFunction FitnessFunction for the agent to operate on
	 */
	public Agent(FitnessFunction fitnessFunction, int n, int programLength, int blockLength, int numBlocks)
	{
		//Switch statement to control which phenotype type is initialized
		this.phenotype = Agent.getRandomPhenotype(n);
		this.fitnessFunction = fitnessFunction;
		this.fitness = fitnessFunction.getFitness(phenotype); 
		
		//Create a random program
		program = new ArrayList<Integer>();
		for(int programIndex=0; programIndex < programLength; programIndex++)
		{
			program.add(SeededRandom.getInstance().nextInt(blockLength));
		}
		//Create random blocks
		blocks = new ArrayList<List<Step>>();
		for(int block=0; block < numBlocks; block++)
		{
			List<Step> thisBlock = new ArrayList<Step>();
			for(int stepIndex=0; stepIndex < blockLength; stepIndex++)
			{
				thisBlock.add(Step.randomStep());
			}
			blocks.add(thisBlock);
		}
		//Compile the program and blocks into the strategy
		this.compileStrategyAndInitializeHistory();
	}
	
	/**
	 * Constructor for Agent. Creates an agent with a given initial phenotype,
	 * program, and blocks.
	 * 
	 * @param fitnessFunction FitnessFunction for the agent to operate on
	 */
	public Agent(FitnessFunction fitnessFunction, Phenotype p, int n, int programLength, int blockLength, int numBlocks)
	{
		this(fitnessFunction, n, programLength, blockLength, numBlocks);
		
		//Set our phenotype to the given one. Make a copy so we don't have a ton of agents linked to the same phenotype
		this.phenotype = p.getIdenticalCopy();
		this.compileStrategyAndInitializeHistory();
	}
	
	/**
	 * Constructor used to exactly specify an agent, with all relevant fields. 
	 * Mostly called by the identicalChild() function.
	 */
	public Agent(FitnessFunction fitnessFunction, Phenotype phenotype, List<Integer> program, List<List<Step>> blocks)
	{
		this.phenotype = phenotype;
		this.fitnessFunction = fitnessFunction;
		this.fitness = fitnessFunction.getFitness(phenotype);
		this.program = program;
		this.blocks = blocks;
		//Compile the program and blocks into the strategy
		this.compileStrategyAndInitializeHistory();
	}
	
	public static Phenotype getRandomPhenotype(int n) {
		switch("nkphenotype") {
			case "nkphenotype":
				return new Bitstring(n);
			default:
				System.out.println("PHENOTYPE_TYPE not recognized");
				return null;
		}
	}
	
	/**
	 * This method compiles the developmental strategy from the program and
	 * the blocks by concatenating copies of the blocks specified in the order
	 * of the program
	 */
	private void compileStrategyAndInitializeHistory()
	{
		strategy = new ArrayList<Step>();
		for(Integer blockIndex : program)
		{
			List<Step> block = blocks.get(blockIndex);
			strategy.addAll(block);
		}
		
		this.phenotypeHistory = new ArrayList<Phenotype>();
		this.phenotypeHistory.add(phenotype);
		this.fitnessHistory = new ArrayList<Double>();
		this.fitness = fitnessFunction.getFitness(phenotype); 
		this.fitnessHistory.add(fitness);
	}
	
	/**
	 * Method to check if the agent has executed all steps in its developmental strategy
	 * @return
	 */
	public boolean agentDeveloped()
	{
		return currentStep == strategy.size();
	}
	
	/**
	 * Executes the current step of the developmental strategy
	 */
	public void executeSingleStep()
	{
		//Get the step to execute and increment step counter
		Step stepToExecute = strategy.get(currentStep);
		currentStep++;
		
		//This is the main switch statement that controls which step is executed
		//When adding new steps, create a new step function and enum in Step, and add
		//it to the switch statement.
		switch(stepToExecute) {
			case RandomWalk:
				randomWalk();
				break;
			case SteepestClimb:
				steepestClimb();
				break;
			case SteepestFall:
				steepestFall();
				break;
		}
		
		//update the agent's fitness value
		fitness = fitnessFunction.getFitness(phenotype);
		
		//Store information
		phenotypeHistory.add(phenotype);
		fitnessHistory.add(fitness);
	}
	
	/**
	 * Executes the entire developmental strategy
	 * 
	 * If strategyExecutionSampleSize>1, this method will
	 * execute the entire strategy many times, but will delete
	 * the contents of pastPhenotypes since tracking past phenotype
	 * with a sample size greater than 1 isn't helpful
	 */
	public void executeStrategy()
	{
		while(!agentDeveloped())
		{
			executeSingleStep();
		}
	}
	
	/**
	 * Makes an identical copy of the agent, except that this is a child
	 * of the current agent, so its parent is set accordingly
	 * 
	 * The child is setup under its initial configuration, so even if the
	 * parent's strategy has been run, the child's strategy will not yet
	 * be run
	 * 
	 * @return child that is identical to the parent
	 */
	public Agent identicalChild()
	{
		//We need to make a copy of each list to ensure the object references aren't passed
		List<Integer> childProgram = new ArrayList<Integer>();
		for(Integer i : program)
		{
			childProgram.add(i);
		}
		
		List<List<Step>> childBlocks = new ArrayList<List<Step>>();
		for(int block=0; block < blocks.size(); block++)
		{
			List<Step> childBlock = new ArrayList<Step>();
			for(Step s : blocks.get(block))
			{
				childBlock.add(s);
			}
			childBlocks.add(childBlock);
		}
		
		Phenotype childPhenotype = phenotype.getIdenticalCopy();
		
		//Use the constructor to make the new agent, and return it
		return new Agent(fitnessFunction, childPhenotype, childProgram, childBlocks);
	}
	
	//-------------------------------------------------------------------------------------------------------------------
	/**
	 * This area is for the different types of steps in the developmental program. These
	 * steps are called during the execution of executeSingleStep or executeStrategy.
	 * 
	 * These steps are only responsible for updating the value in phenotype. Saving previous
	 * phenotypes and updating the fitness is the responsibility of executeSingleStep
	 */
	
	/**
	 * Chooses a random neighbor of the current phenotype to be the new phenotype
	 */
	private void randomWalk()
	{
		List<Phenotype> neighbors = phenotype.getNeighbors();
		phenotype = neighbors.get(SeededRandom.getInstance().nextInt(neighbors.size()));
	}
	
	/**
	 * Chooses the highest fitness neighbor to be the new phenotype
	 */
	private void steepestClimb()
	{
		List<Phenotype> neighbors = phenotype.getNeighbors();
		neighbors.add(phenotype.getIdenticalCopy());
		Phenotype bestNeighbor = neighbors.get(0);
		for(Phenotype neighbor : neighbors)
		{
			if(fitnessFunction.getFitness(neighbor) > fitnessFunction.getFitness(bestNeighbor))
			{
				bestNeighbor = neighbor;
			}
		}
		phenotype = bestNeighbor;
	}
	
	/**
	 * Chooses the lowest fitness neighbor to be the new phenotype
	 */
	private void steepestFall()
	{
		List<Phenotype> neighbors = phenotype.getNeighbors();
		neighbors.add(phenotype.getIdenticalCopy());
		Phenotype worstNeighbor = neighbors.get(0);
		for(Phenotype neighbor : neighbors)
		{
			if(fitnessFunction.getFitness(neighbor) < fitnessFunction.getFitness(worstNeighbor))
			{
				worstNeighbor = neighbor;
			}
		}
		phenotype = worstNeighbor;
	}
	//-------------------------------------------------------------------------------------------------------------------

	
	public List<List<Step>> getBlocks() {
		return blocks;
	}

	public List<Integer> getProgram() {
		return program;
	}

	public List<Double> getFitnessHistory() {
		return fitnessHistory;
	}
	
	public List<Step> getStrategy() {
		return strategy;
	}
	
	public List<Phenotype> getPhenotypeHistory(){
		return phenotypeHistory;
	}
	
	/**
	 * Returns the fitness of the agent if it is developed, otherwise it prints an error and returns -1.
	 * @return
	 */
	public double getFinalFitness() {
		if(agentDeveloped())
		{
			return fitness;
		}
		else
		{
			System.out.println("getFinalFitness called on undeveloped agent");
			return -1;
		}
	}
	
	/**
	 * Returns the phenotype of the agent if it is developed, otherwise it prints an error and returns null.
	 * @return
	 */
	public Phenotype getFinalPhenotype() {
		if(agentDeveloped())
		{
			return phenotype;
		}
		else
		{
			System.out.println("getFinalFitness called on undeveloped agent");
			return null;
		}
	}
}
